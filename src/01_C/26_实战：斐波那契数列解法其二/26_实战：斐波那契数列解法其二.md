### 实战：斐波那契数列解法其二

学习了数组，来看看如何利用数组来计算斐波那契数列，这里采用动态规划的思想。

> 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，希望找到具有[最优值](https://baike.baidu.com/item/最优值)的解。动态规划算法与[分治法](https://baike.baidu.com/item/分治法)类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

可以在一开始创建一个数组，然后从最开始的条件不断向后推导，从斐波那契数列的规律可以得知：

- `fib[i] = fib[i - 1] + fib[i - 2]`（这里`fib`代表斐波那契数列）

得到这样的一个关系（递推方程）就好办了，要求解数列第`i`个位置上的数，只需要知道`i - 1`和`i - 2`的值即可，这样，一个大问题，就分成了两个小问题，比如现在要求解斐波那契数列的第5个元素：

- `fib[4] = fib[3] + fib[2]`现在只需要知道`fib[3]`和`fib[2]`即可，那么我们接着来看：
- `fib[3] = fib[2] + fib[1]`以及`fib[2] = fib[1] + fib[0]`
- 由于`fib[0]`和`fib[1]`已经明确知道是`1`了，那么现在问题其实已经有结果了，把这些小问题的结果组合起来就能得到原来大问题的结果

现在请你设计一个C语言程序，利用动态规划的思想解决斐波那契数列问题。

实现：

```c
#include <stdio.h>

int main() {
    /*
     * 斐波那契数列：1，1，2，3，5，8，13，21，34，55，89...，
     * 不难发现一个规律，实际上从第三个数开始，每个数字的值都是前两个数字的和，
     * 现在请设计一个C语言程序，可以获取斐波那契数列上任意一位的数字，比如获取第5个数，那么就是5。
     */
    int target = 7;
    int fib[target] = {};
    fib[0] = fib[1] = 1;
    for (int i = 2; i < target; i++)
        fib[i] = fib[i - 1] + fib[i - 2];
    printf("%d", fib[target - 1]);
}
```

结果：

```c
13
进程已结束，退出代码为 0
```

