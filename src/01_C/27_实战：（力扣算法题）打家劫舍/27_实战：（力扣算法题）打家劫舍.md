### 实战：打家劫舍

继续通过一道简单的算法题来强化动态规划思想。

**来源：力扣（LeetCode）No.198 打家劫舍**：https://leetcode.cn/problems/house-robber/

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
> 偷窃到的最高金额 = 1 + 3 = 4 。

**示例 2：**

> 输入：[2,7,9,3,1]
> 输出：12
> 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
> 偷窃到的最高金额 = 2 + 9 + 1 = 12 。

这道题也可以很轻松地按照上面的动态规划思路来处理，首先可以将问题分为子问题，比如现在有`[2,7,9,3,1]`五个房屋，这个问题看起来比较复杂，不妨先将大问题先简化成小问题，来看看只有N个房屋的情况：

- 假设现在只有`[2]`这一个房屋，那么很明显，可以直接去偷一号房，得到2块钱，所以当有一个房子时最大能偷到2块钱。

- 假设现在有`[2, 7]`这两个房屋，那么很明显，可以直接去偷二号房，得到7块钱，所以当有两个房子时最大能偷到7块钱。

- 假设现在只有

  ```c
  [2, 7, 9]
  ```

  这三个房屋，就要看看是先偷一号房再偷三号房好，还是只偷二号房好，根据前面的结论，如果偷了一号房，那么就可以继续偷三号房，并且得到的钱就是一号房的钱+三号房的钱，也就是2+9块钱，但是如果只偷二号房的话，那么就只能得到7块钱，所以，三号房能够偷到的最大金额有以下关系（dp是求出的第i个房屋的最大偷钱数量，value表示房屋价值，max表示取括号中取最大的一个）：

  - `dp[i] = max(dp[i - 1], dp[i - 2] + value[i])` -> **递推方程已得到**

- 这样就不难求出：`dp[2] = max(dp[1], dp[0] + value[2])` = `dp[2] = max(7, 2 + 9)` = `dp[2] = 11`，所以有三个房屋时最大的金额是11块钱。

- 所以，实际上只需要关心前面计算出来的盗窃最大值即可，而不需要关心前面到底是怎么在偷。

- 以同样的方式来计算四个房屋的情况：

  ```c
  [2, 7, 9, 3]
  ```

  - `dp[3] = max(dp[2], dp[1] + value[3])` = `dp[3] = max(11, 7 + 3)` = `dp[3] = 11`

- 所以，当有四个房屋时，依然采用先偷一后偷三的方案，不去偷四号，得到最大价值11块钱。

实现：

```c
#include <stdio.h>

int main() {
    int value[] = {2, 7, 9, 3, 1}, size = 5, result;

    int dp[size];
    dp[0] = value[0];
    dp[1] = value[1] > value[0] ? value[1] : value[0];
    for (int i = 2; i < size; ++i) {
        dp[i] = dp[i - 1] > (dp[i - 2] + value[i]) ? dp[i - 1] : (dp[i - 2] + value[i]);
    }
    result = dp[size-1];
    printf("%d", result);
}
```

结果：

```c
12
进程已结束，退出代码为 0
```

官方标准提交（函数与指针）：

```c
int max(int a, int b) {
    return a > b ? a : b;
}

int rob(int* nums, int numsSize){
    if(numsSize == 0) return 0;
    if(numsSize == 1) return nums[0];
    if(numsSize == 2) return max(nums[1], nums[0]);

    int dp[numsSize];
    dp[0] = nums[0];
    dp[1] = max(nums[1], nums[0]);

    for (int i = 2; i < numsSize; ++i) {
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
    }

    return dp[numsSize - 1];
}
```

------