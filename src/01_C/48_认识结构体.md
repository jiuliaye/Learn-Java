## 结构体、联合体和枚举

终于熬过了最难的一个部分，后面的内容就相对简单多了，我们接着来看结构体。

我们之前认识过很多种数据类型，包括整数、小数、字符、数组等，通过使用对应的数据类型，我们就可以很轻松地将我们的数据进行保存了，但是有些时候，这种简单类型很难去表示一些复杂结构。

### 创建和使用结构体

比如现在我们要保存100个学生的信息（学生信息包括学号、姓名、年龄）我们发现似乎找不到一种数据类型能够同时保存这三种数据（数组虽然能保存一些列的元素，但是只能保存同种类型的）。但是如果把它们拆开单独存在，就可以使用对应的类型存放了，不过这样也太不方便了吧，这些数据应该是捆绑在一起的，而不是单独地去存放。所以，为了解决这种问题，C语言提供了结构体类型，它能够将多种类型的数据集结到一起，让他们形成一个整体。

```c
struct Student {   //使用 (struct关键字 + 结构体类型名称) 来声明结构体类型，这种类型是我们自己创建的（同样也可以作为函数的参数、返回值之类的）
    int id;    //结构体中可以包含多个不同类型的数据，这些数据共同组成了整个结构体类型（当然结构体内部也能包含结构体类型的变量）
    int age;
    char * name;   //用户名可以用指针指向一个字符串，也可以用char数组来存，如果是指针的话，那么数据不会存在结构体中，只会存放字符串的地址，但是如果是数组的话，数据会存放在结构体中
};
int main() {
    struct Student {   //也可以以局部形式存在
        
    };
}
```

定义好结构体后，我们只需要使用结构体名称作为类型就可以创建一个结构体变量了：

```c
#include <stdio.h>

struct Student {
    int id;
    int age;
    char * name;
};

int main() {
  	//类型需要写为struct Student，后面就是变量名称
    struct Student s = {1, 18, "小明"};     //结构体包含多种类型的数据（它们是一个整体），只需要把这些数据依次写好放在花括号里面就行了
}
struct Student {
    int id;
    int age;
    char * name;
} s;  //也可以直接在花括号后面写上变量名称（多个用逗号隔开），声明一个全局变量
```

这样我们就创建好了一个结构体变量，而这个结构体表示的就是学号为1、年龄18、名称为小明的结构体数据了。

当然，结构体的初始化需要注意：

```c
struct Student s = {1, 18};   //如果只写一半，那么只会初始化其中一部分数据，剩余的内容相当于没有初始值，跟数组是一样的
struct Student s = {1, .name = "小红"};   //也可以指定去初始化哪一个属性 .变量名称 = 初始值
```

那么现在我们拿到结构体变量之后，怎么去访问结构体内部存储的各种数据呢？

```c
printf("id = %d, age = %d, name = %s", s.id, s.age, s.name);  //结构体变量.数据名称 (这里.也是一种运算符) 就可以访问结构体中存放的对应的数据了
```

是不是很简单？当然我们也可以通过同样的方式对结构体中的数据进行修改：

```C
int main() {
    struct Student s = {1, 18, "小明"};

    s.name = "小红";
  	s.age = 17;

    printf("id = %d, age = %d, name = %s", s.id, s.age, s.name);
}
```

那么结构体在内存中占据的大小是如何计算的呢？比如下面的这个结构体

```c
struct Object {
    int a;
    short b;
    char c;
};
```

这里我们可以借助`sizeof`关键字来帮助我们计算：

```c
int main() {
    printf("int类型的大小是：%lu", sizeof(int));  //sizeof能够计算数据在内存中所占据的空间大小（字节为单位）
}
```

![image-20220625220121753](https://image.itbaima.cn/markdown/2022/06/25/GvmlqIwNQn6Eszo.png)



当然也可以计算变量的值占据的大小：

```c
int main() {
    int arr[10];
    printf("int arr[10]占据的大小是：%lu", sizeof (arr)); //在判断非类型时，sizeof 括号可省
}
```

![image-20220625220323403](https://image.itbaima.cn/markdown/2022/06/25/yogRvUqtucjkYa7.png)



同样的，它也能计算我们的结构体类型会占用多少的空间：

```c
#include <stdio.h>

struct Object {
  	char a;
    int b;
    short c;
};

int main() {
    printf("%lu", sizeof(struct Object));   //直接填入struct Object作为类型
}
```

![image-20220625223336229](https://image.itbaima.cn/markdown/2022/06/25/evxSWPQGMZgEoaA.png)



可以看到结果是8，那么，这个8字节是咋算出来的呢？

> int（4字节）+ short（2字节）+ char（1字节） = 7字节（这咋看都算不出来12啊？）

实际上结构体的大小是遵循下面的规则来进行计算的：

- 结构体中的各个数据要求字节对齐，规则如下：
  - **规则一：**结构体中元素按照定义顺序依次置于内存中，但并不是紧密排列的。从结构体首地址开始依次将元素放入内存时，元素会被放置在其自身对齐大小的整数倍地址上（0默认是所有大小的整数倍）
  - **规则二：**如果结构体大小不是所有元素中最大对齐大小的整数倍，则结构体对齐到最大元素对齐大小的整数倍，填充空间放置到结构体末尾。
  - **规则三：**基本数据类型的对齐大小为其自身的大小，结构体数据类型的对齐大小为其元素中最大对齐大小元素的对齐大小。

这里我们以下面的为例：

```c
struct Object {
  	char a;   //char占据1个字节
    int b;   //int占据4个字节，因为前面存了一个char，按理说应该从第2个字节开始存放，但是根据规则一，必须在自己的整数倍位置上存放，所以2不是4的整数倍位置，这时离1最近的下一个整数倍地址就是4了，所以前面空3个字节的位置出来，然后再放置
    short c; //前面存完int之后，就是从8开始了，刚好满足short（2字节）的整数倍，但是根据规则二，整个结构体大小必须是最大对齐大小的整数倍（这里最大对齐大小是int，所以是4），存完short之后，只有10个字节，所以屁股后面再补两个空字节，这样就可以了
};
```

![image-20220625224302673](https://image.itbaima.cn/markdown/2022/06/25/gpPDKMLw7z3GBOC.png)



这样，就不难得出为什么结构体的大小是12了。