### 实战：汉诺塔

什么是汉诺塔？

> **汉诺塔**（Tower of Hanoi），又称**河内塔**，是一个源于[印度](https://baike.baidu.com/item/印度/121904)古老传说的[益智玩具](https://baike.baidu.com/item/益智玩具/223159)。[大梵天](https://baike.baidu.com/item/大梵天/711550)创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令[婆罗门](https://baike.baidu.com/item/婆罗门/1796550)把圆盘从下面开始
>
> **按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。**

![](../img/img_16.png)

这三根柱子就依次命名为A、B、C，现在请你设计一个C语言程序，计算N阶（n片圆盘）汉诺塔移动操作的每一步。

这个问题看似很难，实际上也可以对每一步进行推理：

> 当汉诺塔只有1阶的情况下：直接把A上的圆盘移动到C，搞定。

> 当汉诺塔只有2阶的情况下：最终目标还是需要将A柱最下面的圆盘丢到C，不过现在多了圆盘，得先把这个圆盘给处理了，所以我们得把这上面的1个圆盘丢到B上去，这样才能把A最下面的圆盘丢给C。然后再把B上面的1个圆盘丢到C上去

> 当汉诺塔只有3阶的情况下：最终目标还是需要将A柱最下面的圆盘丢到C，不过现在多了圆盘，得先把这个圆盘给处理了，所以得把这上面的2个圆盘丢到B上去，这样才能把A最下面的圆盘丢给C。然后再把B上面的2个圆盘丢到C上

实际上，把A移动到C是一定要进行的，而在进行之前需要先把压在上面全部的圆盘全部放到B去。而移动之后也要把B上的圆盘全部移动到C上去。其实所有的情况下最终都会有一个n=1的情况，将A上的最后一个圆盘移动到C，只是多了一个前面的步骤和后面的步骤。

不过难点就是，怎么把A上的n-1个圆盘移动到B去呢？其实这时可以依靠C作为中间商，来帮助移动（比如n = 3，先把最上面的移动到C，然后把第二大的移动到B，再从C上把最小的移动到B上，这样就借助了C完成了两个圆盘的转移），而最后又怎么把B上的圆盘全部移到C去呢，这时就可以依靠A作为中间商，方法同理；实际上大问题最后都会变成n = 2时这样的小问题，只不过是要移动目标不同罢了。

只要想通了怎么去借助中间商进行移动，就很好写出程序了。

这个问题主要分为两步：

1. B作为中间商，将n-1个全部移动到B上，第n个移动到C上：`hanoi(a, c ,b, n - 1);move(a, c, n); `
2. A作为中间商，将n-2个全部移动到A上，第n-1个移动到C上，此时又会回到第一步的情况：`hanoi(b, a, c, n - 1); `

递归函数如下设计：

```c
//a存放圆盘的初始柱子，b作为中间柱子存放使用，c作为目标柱子，n表示要从a移动到c的圆盘数
void hanoi(char a, char b, char c, int n){
    
}
```

```c
void move(char start, char end, int n){   //用于打印移动操作到控制台，start是起始柱子，end是结束柱子，n是哪一个圆盘
    printf("第%d个圆盘：%c --> %c\n", n, start, end);
}

void hanoi(char a, char b, char c, int n){  //刚进来的时候，B作为中间柱子，C作为目标柱子，要移动A上的n个圆盘到C去
    if(n == 1) {
        move(a, c, n);   //无论a,b,c如何变换，通过递归，最后都会变成一个n = 1的问题，直接移动就完事了
    } else{
        hanoi(a, c ,b, n - 1);  //首要目标是先把上面n-1个圆盘全部放到B去，这里就变换一下，让B作为目标柱子，C作为中间
        move(a, c, n);   //现在A上只剩下一个最大的圆盘了，接着把A最下方的一个圆盘移到C去
        hanoi(b, a, c, n - 1);   //最后需要把B上的全部搬到C上去，这里就可以以C为目标柱子，A为中间柱子
    }
}
```

简化一波：

```c
void hanoi(char a, char b, char c, int n){
    if(n == 0) return;
    hanoi(a, c ,b, n - 1);
    printf("第%d个圆盘：%c --> %c\n", n, a, c);
    hanoi(b, a, c, n - 1);
}
```

看似如此复杂的问题，其实只需要4行就可以解决了。