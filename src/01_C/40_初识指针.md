### 什么是指针

通过函数交换两个变量的值

```c
#include <stdio.h>

void swap(int, int);

int main() {
    int a = 10, b = 20;
    swap(a, b);

    printf("a = %d, b = %d", a, b);   //最后会得到什么结果？
}

void swap(int a, int b){
    int tmp = a;   //这里对a和b的值进行交换
    a = b;
    b = tmp;
}
```

实际上这种写法是错误的，因为交换的并非是真正的a和b，而是函数中的局部变量。需要指针的帮助才能够直接对函数外部的变量进行操作。

程序中使用的变量实际上都是在内存中创建的，每个变量都会被保存在内存的某一个位置上（具体在哪个位置是由系统分配的），所有的变量在对应的内存位置上都有一个地址（地址是独一无二的），可以通过这个地址寻找到这个变量本体，比如int占据4字节，因此int类型变量的地址就是这4个字节的起始地址，后面32个bit位全部都是用于存放此变量的值的。

![](./img/img_17.png)

这里的`0x`是十六进制的表示形式（10-15用字母A - F表示）如果能够知道变量的内存地址，那么无论身在何处，都可以通过地址找到这个变量了。

**而指针的作用，就是专门用来保存这个内存地址的。**

如何创建一个指针变量用于保存变量的内存地址：

```c
#include <stdio.h>

int main(){
    int a = 10;
  	//指针类型需要与变量的类型相同，且后面需要添加一个*符号（注意这里不是乘法运算）表示是对于类型的指针
    int * p = &a;   //这里的&并不是进行按位与运算，而是取地址操作，也就是拿到变量a的地址
    printf("a在内存中的地址为：%p", p);  //地址使用%p表示
}
```

通过取地址操作`&`，将变量a的地址保存到了一个地址变量`p`中。

拿到指针之后，可以很轻松地获取指针所指地址上的值：

```c
#include <stdio.h>

int main(){
    int a = 666;
    int * p = &a;
    printf("内存%p上存储的值为：%d", p, *p);   //可以在指针变量前添加一个*号（间接运算符，也可以叫做解引用运算符）来获取对应地址存储的值
}
```

注意这里访问指针所指向地址的值时，是根据类型来获取的，比如int类型占据4个字节，那么就读取地址后面4个字节的内容作为一个int值，如果指针是char类型的，那么就只读取地址后面1个字节作为char类型的值。

同样的，也可以直接去修改对应地址存放的值：

```c
#include <stdio.h>

int main(){
    int a = 666;
    int * p = &a;

    *p = 999;   //通过*来访问对应地址的值，并通过赋值运算对其进行修改

    printf("a的值为：%d", a);
}
```

实际上拿到一个变量的地址之后，完全不需要再使用这个变量，而是可以通过它的指针来对其进行各种修改。

因此，想要实现对两个变量的值进行交换的函数就很简单了：

```c
#include <stdio.h>

// 这里是两个指针类型的形参，其值为实参传入的地址，
// 虽然依然是值传递，但是这里传递的是地址
// 传两个地址，再在函数内取值
void swap(int * a, int * b){
    int tmp = *a;   //先暂存一下变量a地址上的值
    *a = *b;   //将变量b地址上的值赋值给变量a对应的位置
    *b = tmp;   //最后将a的值赋值给b对应位置，这样就成功交换两个变量的值了
}

int main(){
    int a = 10, b = 20;
    swap(&a, &b);   //只需要把a和b的内存地址给过去就行了，这里取一下地址
    printf("a = %d, b = %d", a, b);
}
```

**结果：a = 20, b = 10**

通过地址操作，轻松实现了使用函数交换两个变量的值了。

了解了指针的相关操作之后，再来看看`scanf`函数，实际上就很好理解了：

```c
#include <stdio.h>

int main(){
    int a;
    scanf("%d", &a);   //这里就是取地址，需要告诉scanf函数变量的地址，这样它才能通过指针访问变量的内存地址，对变量的值进行修改，这也是为什么scanf里面的变量（除数组外）前面都要进行一个取地址操作
    printf("%d", a);
}
```

当然，和变量一样，要是不给指针变量赋初始值的话，就不知道指的哪里了，因为指针变量也是变量，存放的其他变量的地址值也在内存中保存，如果不给初始值，那么地址的这块内存可能在其他地方使用过，这样就不知道初始值是多少了（那么指向的地址可能是一个很危险的地址，随意使用可能导致会出现严重错误），所以一定要记得给个初始值或是将其设定为NULL，表示空指针，不指向任何内容。

```c
#include <stdio.h>

int main(){
    int * a = NULL;
}
```

接着来看看`const`类型的指针，这种指针比较特殊：

```c
#include <stdio.h>

int main(){
    int a = 9, b = 10;
    const int * p = &a;
    *p = 20;   //这里直接报错，因为被const标记的指针，所指地址上的值不允许发生修改
  	p = &b;   //但是指针指向的地址是可以发生改变的
}
```

再来看另一种情况：

```c
#include <stdio.h>

int main(){
    int a = 9, b = 10;
    int * const p = &a;   //const关键字被放在了类型后面
    *p = 20;   //允许修改所指地址上的值
    p = &b;   //但是不允许修改指针存储的地址值，其实就是反过来了。
}
```

当然也可以双管齐下：

```c
#include <stdio.h>

int main(){
    int a = 9, b = 10;
    const int * const p = &a;
    *p = 20;   //两个都直接报错，都不让改了
    p = &b;
}
```

其实指针只要分明白哪个是值、哪个是地址就清楚多了