### 实战：快速排序算法

有一个数组：

```c
int arr[] = {4, 3, 8, 2, 1, 7, 5, 6, 9, 0};
```

现在请你设计一个C语言程序，对数组按照**从小到大**的顺序进行排序。这里使用冒泡排序的进阶版本——**快速排序**来完成，它的核心思想是分而治之：

- 每一轮排序都会选出一个基准，一轮排序完成后，所以比基准小的数一定在左边，比基准大的数一定在右边，在分别通过同样的方法对左右两边的数组进行排序，不断划分，最后完成整个数组的排序。
- 它的效率相比冒泡排序的双重for循环有所提升。

1. 首先将第一个元素作为基准
2. 两个箭头分别指向左右两端
3. 首先从右边开始，不断和基准进行比较，如果发现比基准要小，则将箭头所指元素丢到左边箭头位置处，直接覆盖，然后右边不动开始从左往右移动左边的箭头
4. 从左往右，不断将箭头所指的数和基准进行比较，如果发现比基准要大，那么则将箭头所指元素丢到右侧箭头位置，直接覆盖，然后重复第3步，直到两个箭头相遇。
5. 两个箭头相遇后，相遇位置就是基准的最终排序位置
6. 最后，左右两边一定左边比基准小，右边比基准大，但是并不一定是有序的。

```c
#include <stdio.h>

void quickSort(int arr[], int left, int right) {  //arr是数组，left是起始下标，right是结束下标
    if (left >= right)return;
    int base = arr[left], l = left, r = right;
    while (l < r) {
        while (l < r && arr[r] >= base)r--;
        arr[l] = arr[r];
        while (l < r && arr[l] <= base)l++;
        arr[r] = arr[l];
    }
    arr[r] = base;
    quickSort(arr, left, r - 1);
    quickSort(arr, r + 1, right);
}

int main() {
    int arr[] = {4, 3, 8, 2, 1, 7, 5, 6, 9, 0};
    quickSort(arr, 0, 9);  //10个数字下标就是0-9
    for (int i = 0; i < 10; ++i) {
        printf("%d ", arr[i]);
    }
}
```

结果：

```c
0 1 2 3 4 5 6 7 8 9 
进程已结束，退出代码为 0
```

不过虽然这种排序算法很快，但是极端情况下（比如遇到了刚好倒序的数组）还是会退化成冒泡排序的。