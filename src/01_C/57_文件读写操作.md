## 文件输入/输出

由于文件需要被长期保存，所以它们被统一存放到电脑的硬盘中。

硬盘不像内存，虽然它们都可以存放数据，但是内存中的数据断电即失，而硬盘却支持长期保存数据，当然也是以二进制的形式进行保存的。

### 文本读写操作

现代计算机使用的硬盘大致分为固态硬盘和机械硬盘两种，其中固态硬盘的读写速度远超机械硬盘，但是寿命（硬盘是有读写次数限制的，如果读写次数超标，那么就无法使用了）不如机械硬盘，所以一般重要数据都是在机械硬盘中存放，而系统文件一般是在固态硬盘中存放，这样电脑的启动速度会很快。

不过文件并不是随便在硬盘中进行保存的，而是根据不同的文件系统按规则进行存放的，比如Windows下采用的就是NTFS文件系统，而MacOS采用的是APFS文件系统。

> 文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。

其中某些文件是以文本格式存储的，比如C语言源文件、普通的文本文档等；而有些文件是二进制格式，比如图片、视频、应用程序等，但是它们最终都是以二进制的形式存储到硬盘上的。

当然，普通的文本文件直接打开记事本都可以直接进行编辑，而图片这类二进制文件，需要使用专门读取图片的软件来查看，根据格式的不同（图片有png、jpg等格式）对文件的解读方式也不一样，但是最后都会被专门的图片查看软件展示出来。

通过使用C语言，也可以读取硬盘上的文件，这里我们先创建一个简单的文本文件：

`hello.txt`

接着可以使用stdio.h中提供的函数打开一个文件：

```c
#include <stdio.h>

int main() {
    FILE * file = fopen("hello.txt", "rw");  //使用fopen函数来打开一个文件
}
```

这里先来介绍一下参数：

- 第一个参数：文件的名称，这里我填写的是相对路径，也可以写成绝对路径
- 第二个参数：打开文件的模式，其中模式有以下这些：

|               模式字符串               |                             含义                             |
| :------------------------------------: | :----------------------------------------------------------: |
|                  “r”                   |                       以读模式打开文件                       |
|                  “w”                   | 以写模式打开文件，把现有文件的长度截为0，如果文件不存在，则创建一个新文件 |
|                  “a”                   | 以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件 |
|                  “r+”                  |      以更新模式打开文件（即可以读写文件）该文件必须存在      |
|                  “w+”                  | 以更新模式打开文件（即可以读写文件），如果文件存在，则将其长度截为0；如果文件不存在，则创建一个新文件 |
|                  “a+”                  | 以更新模式打开文件（即，读写），在现有文件的末尾添加内容，如果文件不存在则创建一个新文件；可以读整个文件，但是只能从末尾添加内容 |
| “rb”,“wb”,“ab”,“ab+”,“a+b”,“wb+”,“w+b” | 与“a+”模式类似，但是以二进制模式打开文件而不是以文本模式打开文件 |

具体的不同打开模式会影响到后续的操作

然后这个函数返回的是一个FILE结构体指针：

```c
typedef struct __sFILE {
   unsigned char *_p; /* current position in (some) buffer */
   int    _r;       /* read space left for getc() */
	 ...
} FILE;
```

定义非常复杂，这里我们就不详细介绍了，这样就成功打开了这个文件，那么如何对文件进行读取操作呢？

可以使用`getc`来快速读取文件中的字符：

```c
#include <stdio.h>

int main() {
    FILE * file = fopen("hello.txt", "r");
    int c;
    while ((c = getc(file)) != EOF) {   //通过一个while循环来不断读取文件，使用getc从文件中读取一个字符，如果到末尾了，那么会返回一个特殊值EOF
        putchar(c);   //使用putchar来快速打印字符到控制台
    }
}
```

当然如果没有这个文件或是文件打开失败的话，可能会返回一个空指针，所以我们需要进一步判断：

```c
#include <stdio.h>

int main() {
    FILE * file = fopen("hello.txt", "r");
    if(file != NULL) {   //如果打开失败会返回NULL
        int c;
        while ((c = getc(file)) != EOF) {
            putchar(c);
        } 
    } else{
        puts("文件打开失败！");
    }
}
```

最后在使用完文件后，记得关闭文件来释放资源，不然一直会被占用：

```c
fclose(file);   //fclose用于关闭文件
```

写入同样可以使用`putc`来完成：

```c
#include <stdio.h>

int main() {
    FILE * file = fopen("hello.txt", "w");   //注意这里需要修改为写模式
    if(file != NULL) {
        for (int i = 0; i < 10; ++i)
            putc('A' + i, file);   //从A开始依次写入10个字符
        fclose(file);
    } else{
        puts("文件打开失败！");
    }
}
```

文件的读写实际上并不是直接对文件进行操作的，在这之间还有一个缓冲区：

所有的读操作，首先是从文件读取到缓冲区中，再从缓冲区中读取到程序中的；写操作就是先写入到缓冲区，然后再从缓冲区中写入到文件中。这样做的目的是，因为内存和硬盘的速度差距有点大，为了解决这种速度差异导致的性能问题，所以设定一个缓冲区，这样就算速度不一样，但是内容被放在缓冲区中慢慢消化就没问题了。

虽然缓冲区能够解决这些问题，但是也会带来一些不便之处，比如下面的例子：

```c
#include <stdio.h>

int main() {
    FILE * file = fopen("hello.txt", "a+");   //注意这里需要修改为写模式
    if(file != NULL) {
        while (1) {
            int c = getchar();   //不断从控制台读取字符
            if(c == 'q') break;
            putc(c, file);  //写入到文件中
        }
        fclose(file);
    }
}
```

当敲了一个字符之后，可能并不会马上更新到文件中，这就是由于缓冲区没有及时同步到文件中，所以需要调用一个函数来刷新缓冲区，将那些缓冲区的没有同步的数据全部同步到文件中：

```c
#include <stdio.h>

int main() {
    FILE * file = fopen("hello.txt", "a+");
    if(file != NULL) {
        while (1) {
            int c = getchar();
            if(c == 'q') break;
            putc(c, file);
            fflush(file);   //使用fflush来刷新缓冲区
        }
        fclose(file);
    }
}
```

这样就可以看到输入一个字符马上就能同步更新了。当然也可以手动设定缓冲区的大小：

```c
char buf[3];
setvbuf(file, buf, _IOFBF, 3);
```

其中：

- _IONBF：表示不使用缓冲区
- _IOFBF：表示只有缓冲区填满了才会更新到文件
- _IOLBF：表示遇到换行就更新到文件

除了使用`getc`之外，标准库中还提供了`fprintf`和`fgets`系列函数：

```c
#include <stdio.h>

int main() {
    FILE * file = fopen("hello.txt", "a+");
    if(file != NULL) {
        fprintf(file, "树脂%d", 666);   //fprintf就像普通的打印一样，但是它并不是打印到控制台，而是文件中
        fclose(file);
    }
}
#include <stdio.h>

int main() {
    FILE * file = fopen("hello.txt", "w");
    if(file != NULL) {
        fputs("小黑子苏珊", file);   //就像使用puts一样，同样是输出到文件中
        fclose(file);
    }
}
```