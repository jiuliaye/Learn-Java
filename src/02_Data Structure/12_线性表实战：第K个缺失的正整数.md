### （简单）第 k 个缺失的正整数

本题来自LeetCode：[1539. 第 k 个缺失的正整数](https://leetcode.cn/problems/kth-missing-positive-number/)

给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。

请你找到这个数组里第 k 个缺失的正整数。

示例 1：

> 输入：arr = [2,3,4,7,11], k = 5
> 输出：9
> 解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。

示例 2：

> 输入：arr = [1,2,3,4], k = 2
> 输出：6
> 解释：缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。

实际上这种问题，我们第一个能够想到的就是直接通过遍历挨个寻找，从头开始一个一个找，总能找到第K个吧？我们可以很轻松地得到如下的代码：

```c
int findKthPositive(int* arr, int arrSize, int k){
    int j = 1, i = 0;   //直接从第一个元素开始挨个找
    while (i < arrSize) {
        if(arr[i] != j) {
            if(--k == 0) return j;   //发现不相等时，相当于找到了一个数，k自减，如果自减后为0，那么说明已经找到第K个了，直接返回对应的j
        } else{
            i++;  //相等的话就继续看下一个
        }
        j++;   //每一轮j自增，表示下一轮应该按顺序匹配的数
    }
    return j + k - 1;   //如果遍历完了都还没找到，那就按顺序直接算出下一个
}
```

不过这样的效率并不高，如果这个数组特别长的话，那么我们总不可能还是挨个看吧？这样的遍历查找算法的时间复杂度为O(n)，那么有没有更好的算法能够解决这种问题呢？

既然这个数组是有序的，那么我们不妨直接采用二分搜索的思想，通过使用二分搜索，我们就可以更快速地找到对应的位置，但是有一个问题，我们怎么知道二分搜索找到的数，是不是第N个数呢？实际上也很简单，通过规律我们不难发现，如果某个位置上的数不匹配，那么被跳过的数`k`一定满足：
$$
k = arr[i] - i - 1
$$
- `(i+1)`为如果没有缺失任何数字时应该存在的数组

- `arr[i]-(i+1)`则可以算出此时`i`位置对应的`k`

所以，我们只需要找到一个大于等于`k`的位置即可，并且要尽可能的接近，在找到之后，再根据公式去寻找即可：

```c
int findKthPositive(int *arr, int arrSize, int k) {
    if (arr[0] > k) return k;
    
    int l = 0, r = arrSize;
    while (l < r) {
        int mid = (l + r) / 2;
        if (arr[mid] - mid - 1 >= k) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }

    return k - (arr[l - 1] - (l - 1) - 1) + arr[l - 1];//k-ki即还差的步数，arr[l-1]+步数则为第k个缺失的数字
}
```



