面试推荐书籍，内含多种常用算法以及解题分析，值得一看：

![image-20220709170248015](https://s2.loli.net/2022/07/09/TurKEpDHmvlgJhZ.png)

本篇内容虽然继续以C语言为基础进行讲解，但是将不再涉及到C语言的语言层面相关内容，更多的是数据结构和算法的思想，实际上用任意一种语言都可以实现。

***

## 什么是数据结构与算法

### 数据结构

>  数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的[逻辑结构](https://baike.baidu.com/item/逻辑结构/9663235)和数据的物理结构以及它们之间的相互关系。

比如现在需要保存100个学生的数据，那么首先想到的肯定是使用数组！没错，没有什么比数组更适合存放这100个学生的数据了，但是如果现在有了新的需求：不仅仅是存放这些数据，还希望能够将这些数据按顺序存放，支持在某个位置插入一条数据、删除一条数据、修改一条数据等，这时候，数组就显得有些乏力了。

![image-20220710103307583](https://s2.loli.net/2022/07/10/9RwL7pxgyfoB3WT.png)

需要一种更好的数据表示和组织方式，才能做到类似于**增删改查**这样的操作，而完成这些操作所用到的方法，我们称其为“算法”，所以数据结构和算法，一般是放在一起进行讲解的。

### 算法

比如现在我们希望你求出1-100所有数字的和，请通过程序来实现：

```c
int main() {
    int sum = 0;
    for (int i = 1; i <= 100; ++i) sum += i;
    printf("%d", sum);
}
```

我们很容易就能编写出这样的程序，实际上只需要一个for循环就能搞定了，而这就是我们设计的算法。

![image-20220709223103628](https://s2.loli.net/2022/07/09/srPn4baDXWZ9qcJ.png)

在之前的C语言程序设计阶段，我们其实已经学习了许多算法，包括排序算法、动态规划等。

当然，解决问题的算法并不是只有一种，实际上我们上面的方式并不是最优的算法，如果想要求得某一段整数的和，其实使用**高斯求和公式**能够瞬间得到结果：
$$
\sum=\frac{(首项+末项)\times项数}{2}
$$
所以，我们完全没必要循环那么多次进行累加计算，而是直接使用数学公式：

```c
int main() {
    printf("%d", (1 + 100) * 100 / 2);
}
```

所以，算法的尽头还得是数学啊。

可见，不同的算法，执行的效率也是有很大差别的，这里我们就要提到算法的复杂度了。衡量一个算法的复杂程度需要用到以下两个指标：

* 时间复杂度`T(n)`：算法程序在执行时消耗的时间长度，一般与输入数据的规模n有关。
* 空间复杂度`S(n)`：算法程序在执行时占用的存储单元长度，同样与数据的输入规模n有关，大部分情况下，我们都是采取空间换时间的算法。

比如我们上面的两种算法，第一种需要执行n次循环，每轮循环进行一次累加操作，而第二种只需要进行一次计算即可。实际中我们计算时间复杂度时，其实并不一定要计算精确的执行次数，而只需要大概执行次数，那么这里我们使用`O`渐进表示法。

* **大O符号（Big O notation）**：是用于描述函数渐进行为的数学符号。

而这里的循环次数，实际上就是我们需要知道的大致执行次数，所以第一种算法的时间复杂度为：`O(n)`，其中n就是项数，因为它需要执行n次计算才能得到最后的结果。而第二种算法的时间复杂度为：`O(1)`，因为它只需要执行一次计算（更准确的说它的执行次数是一个常数，跟项数n毫无关系），显然，当n变得非常大时，第二种方法的计算速度远超第一种。

再比如我们之前使用的冒泡排序算法，需要进行两轮循环，而循环的次数在经过优化之后为`(n - 1)(n - 1)/2`，得到的结果中包含了一个`n`的平方，此时这种算法的时间复杂度就来到`O(n^2)`了。

在不同的空间复杂度下，可能n小的时候还没什么感觉，但是当n变得非常大时，差距就不是一点半点了，我们来看看常用函数的增长曲线：

![image-20220709230756755](https://s2.loli.net/2022/07/09/Tr6jI5uPzy2NeDd.png)

所以我们在设计算法的时候，一定要考虑到时间和空间复杂度的问题，这里列出常用函数的增长表：

|       函数        |    类型    |                             解释                             |
| :---------------: | :--------: | :----------------------------------------------------------: |
|         1         |   常数阶   |   如果算法能够优化到这个程度，那么基本上算是最快的算法了。   |
| log<sub>2</sub>n  |   对数阶   | 仅次于常数阶的速度，我们后面会介绍的二分搜索算法，就能够到达这个级别。 |
|         n         |   线性阶   | 我们后面介绍的线性表插入、删除数据，包括动态规划类算法能够达到线性阶。 |
| nlog<sub>2</sub>n | 线性对数阶 |          相当于在对数阶算法外层套了一层线性阶循环。          |
|   n<sup>2</sup>   |   平方阶   | 我们前面学习的冒泡排序，需要进行两重循环，实际上就是平方阶。 |
|   n<sup>3</sup>   |   立方阶   |         从立方阶开始，时间复杂度就开始变得有点大了。         |
|   2<sup>n</sup>   |   指数阶   | 我们前面介绍的斐波那契数列递归算法，就是一个指数阶的算法，因为它包含大量的重复计算。 |
|        n!         |    阶乘    | 这个增长速度比指数阶还恐怖，但是一般很少有算法能达到这个等级。 |

我们在编写算法时，一定要注意算法的时间复杂度，当时间复杂度太大时，可能计算机就很难在短时间内计算出结果了。





